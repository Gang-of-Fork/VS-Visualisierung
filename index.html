<!doctype html>
<html lang="de">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">

    <title>Visualisierung Verteilte Systeme</title>
</head>

<body>
    <div id="title" style="visibility: hidden; position: absolute;">
        <h3>X-Größe: <span id="xsize"></span> Y-Größe: <span id="ysize"></span> Anzahl der Nodes: <span
                id="numOfNodes"></span></h3>
    </div>
    <div class="row">
        <div id="visualization" class="col"></div>
        <div class="col">
            <div class="card" style="margin-bottom: 30px;">
                <div class="card-body">
                    <div class="mb-3">
                        <label for="formFile" class="form-label">Daten auswählen</label>
                        <input class="form-control" type="file" id="upload">
                    </div>
                </div>
            </div>

            <div class="row">
                <div class="col">
                    <div id="nodeInfo" class="card" style="width: 100%;">
                        <div id="initNodeInfo" class="card-body">
                        <h5 class="card-title">Node Info</h5>
                        <p class="card-text">Selektiere eine Node um weitere Informationen zu erhalten</p>
                        </div>
                    </div>
                </div>
                <div class="col">
                    <div id="dataLog" class="card" style="width: 100%;">
                        <div id="initDataLog" class="card-body">
                        <h5 class="card-title">Daten Log</h5>
                        <p class="card-text">Lade eine Datei hoch, um hier den Log zu verfolgen</p>
                        </div>
                    </div>
                    <!--Slider for Log Navigation-->
                    <div style="text-align: center; margin-top: 20px; padding: 10px;">
                        <div id="dataRagenSlider"></div>
                    </div>

                </div>
              </div>
        </div>
    </div>


    <!-- Optional JavaScript; choose one of the two! -->

    <!-- Option 1: Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
        crossorigin="anonymous"></script>

    <!-- Include D3.js -->
    <script src="https://d3js.org/d3.v4.js"></script>

    <style>

    body {
        margin: 40px;
    }
    
    
    .shadow {
        -webkit-filter: drop-shadow( 0px 0px 5px white );
                filter: drop-shadow( 0px 0px 5px #000 ); /* Same syntax as box-shadow */
    }
    </style>

    <!-- Configuration constants -->
    <script>
        const dot_radius = 0.75;
    </script>

    <!-- Custom D3.js code -->
    <script>
        var currentState = 0;
        var testdata; //will be assigned if data is read


        // set the dimensions and margins of the graph
        const margin = { top: 30, right: 30, bottom: 30, left: 30 };
        const width = 800 - margin.left - margin.right;
        const height = 800 - margin.top - margin.bottom;

        const rScale = d3.scaleLinear()
            .domain([0, 100])
            .range([0, height])

        const label_size = rScale(dot_radius) * 1.2;


        function initViz(data) {

            const nodeInfo = d3.select("#nodeInfo")
                .append("div")
                .classed("card-body", true)
                .style("position", "absolute")
                .style("visibility", "hidden")
                .text("I'm a Node Info");


            //reset function for later selection
            const resetSelection = function () {
                console.log("reset");
                //reset stroke width
                d3.selectAll("circle").attr("stroke-width", "1px");
                d3.select("#circleRange").remove();
                //remove card info
                d3.select("#initNodeInfo").remove();
                d3.select("#specificNodeInfo").remove();
                console.log(nodeInfo);
                return d3.select("#nodeInfo") 
                    .append("div")
                    .classed("card-body", true)
                    .attr("id", "initNodeInfo")
                    .style("visibility", "visible")
                    .style("position", "relative")
                    .html(`<h5 class="card-title">Node Info</h5>
                  <p class="card-text">Selektiere eine Node um weitere Informationen zu erhalten</p>`);
            }

            //append the svg object to the visualization div
            const svg = d3.select("#visualization")
                .append("svg")
                .on("click", resetSelection)
                .attr("id", "svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                // translate this svg element to leave some margin.
                .append("g")
                .attr("id", "vis_svg")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

            // X scale and Axis
            const x = d3.scaleLinear()
                .domain([0, 100])         // This is the min and the max of the data: 0 to 100 if percentages
                .range([0, width]);       // This is the corresponding value I want in Pixel

            svg
                .append('g')
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));

            // X scale and Axis
            const y = d3.scaleLinear()
                .domain([0, 100])         // This is the min and the max of the data: 0 to 100 if percentages
                .range([height, 0]);       // This is the corresponding value I want in Pixel

            svg
                .append('g')
                .call(d3.axisLeft(y))

            const tooltip = d3.select("#visualization")
                .append("div")
                .classed("card", true)
                .attr("id", "circleBasicTooltip")
                .style("position", "absolute")
                .style("visibility", "hidden")
                .style("z-index", "900")
                .text("I'm a circle!");

            //define Node-Events
            const mouseover = function (d) {
                d3.select(this).style("cursor", "pointer");
                return tooltip
                    .style("visibility", "visible")
                    .html("Node ID: " + d.id + "<br/> X: " + d.x + " Y: " + d.y);
            }

            const mousemove = function () {
                return tooltip.style("top", (event.pageY - 20) + "px")
                    .style("left", (event.pageX + 20) + "px")
            }

            const mouseleave = function () { 
                d3.select(this).style("cursor", "default"); 
                return tooltip.style("visibility", "hidden"); 
            }

            const click = function (d) {
                event.stopPropagation();
                //remove card info
                d3.select("#initNodeInfo").remove();
                d3.select("#specificNodeInfo").remove();
                //change stroke-width of selected node
                d3.selectAll("circle").attr("stroke-width", "1px");
                var node = d3.select(`#nodeCircle${d.id}`).attr("stroke-width", "1.5px");
                d3.select("#circleRange").remove();
                var cx = node._groups[0][0].attributes.cx.value;
                var cy = node._groups[0][0].attributes.cy.value;
                //set range of nodes
                d3.select("#vis_svg").insert("circle", "circle")
                    .attr("id", "circleRange")
                    .attr("cx", cx)
                    .attr("cy", cy)  
                    .attr("r", rScale(dot_radius + 8.75))
                    .style("stroke-dasharray", ("10,5"))
                    .style("stroke", "green") 
                    .style("fill-opacity", .2)
                    .style("fill", "green");
                let html = `<h5 class="card-title">Node Info</h5>
                        <h6 class="card-subtitle mb-2 text-muted">Node ID: ${d.id}</h6>
                        <p class="card-text">X: ${d.x}, Y: ${d.y} </br>`
                if(d.inRange.length > 0){
                    html += `In Reichweite: ${d.inRange}`
                }
                if(d.routingTable.length > 0){
                    html += `<h6>Routing Tabelle:</h6>
                            <table class="table">
                            <thead>
                                <tr>
                                <th scope="col">Destination</th>
                                <th scope="col">Route</th>
                                </tr>
                            </thead>
                            <tbody>`
                    for(let x of d.routingTable){
                        console.log(x);
                        html += `<tr>
                                    <td>${x.destination}</td>
                                    <td>${x.route.replaceAll(";", " - ")}</td>
                                </tr>` 
                    }
                    html += `</tbody></table>`
                }
                html += `</p>`
                
                return d3.select("#nodeInfo") 
                    .append("div")
                    .classed("card-body", true)
                    .attr("id", "specificNodeInfo") 
                    .style("visibility", "visible")
                    .style("position", "relative")
                    .html(html);
            }

            const elemEnter = svg
                .selectAll("enterEle")
                .data(data)
                .enter()

            const circles = elemEnter
                .append("circle")
                .attr("id", function(d) { return "nodeCircle" + d.id})
                .attr("cx", function (d) { return x(d.x) })
                .attr("cy", function (d) { return y(d.y) })
                .attr("r", rScale(dot_radius))
                .attr("stroke", "black")
                .attr("fill", "white")
                .on("mouseover", mouseover)
                .on("mousemove", mousemove)
                .on("mouseleave", mouseleave)
                .on("click", click);

            const texts = elemEnter
                .append("text")
                .attr("id", function(d) { return "nodeText" + d.id })
                .attr("x", function (d) { return x(d.x) })
                .attr("y", function (d) { return y(d.y) + 0.4 * label_size })
                .attr('font-size', label_size)
                .attr("text-anchor", "middle")
                .text(function (d) { return "" + d.id })
                .on("mouseover", mouseover)
                .on("mousemove", mousemove)
                .on("mouseleave", mouseleave)
                .on("click", click);
        }

        function resetViz() {
            console.log(document.getElementsByTagName("div"));
            document.getElementById("visualization").innerHTML = "";
        }


        function rreq(data){
            d3.select(`#nodeCircle${data.actions.sending}`).attr("fill", "#bce6eb");
            for(let i = 0; i < data.actions.receiving_discarding.length; i++){
                d3.select(`#nodeCircle${data.actions.receiving_discarding[i]}`).attr("fill", "#ff8585");
            }
            for(let i = 0; i < data.actions.receiving_processing.length; i++){
                d3.select(`#nodeCircle${data.actions.receiving_processing[i]}`).attr("fill", "#d2f5e3");
                connectNodesByArrow(data.nodes[data.actions.sending ], data.nodes[data.actions.receiving_processing[i] ], d3.select("#vis_svg"));
            }
        }

        function rres(data){
            d3.select(`#nodeCircle${data.actions.sending}`).attr("fill", "#bce6eb");
            for(let i = 0; i < data.actions.receiving_discarding.length; i++){
                d3.select(`#nodeCircle${data.actions.receiving_discarding[i]}`).attr("fill", "#ff8585");
            }
            for(let i = 0; i < data.actions.receiving_processing.length; i++){
                d3.select(`#nodeCircle${data.actions.receiving_processing[i]}`).attr("fill", "#d2f5e3");
                connectNodesByArrow(data.nodes[data.actions.sending ], data.nodes[data.actions.receiving_processing[i] ], d3.select("#vis_svg"));
            }
        }

        function rtu(data){
            const pulse = function () {
                var circle = d3.select("#pulseCircle");
                console.log(circle);
                (function repeat() {
                    circle = circle.transition()
                        //reset pulsing circle to node size
                        .duration(0)
                        .attr("stroke-width", 1.25)
                        .attr("r", rScale(dot_radius))
                        .style("opacity","1")
                        //let circle grow and fade the color out
                        .transition()
                        .duration(2000)
                        //.ease(d3.easeLinear)
                        .attr('stroke-width', 1.25)
                        .attr("r", rScale(dot_radius + 8.75))
                        .style("opacity","0")
                        .on("end", repeat);
                })();
            }
            var node = d3.select(`#nodeCircle${data.table_update.node}`);
            console.log(node._groups[0][0].attributes);
            var cx = node._groups[0][0].attributes.cx.value;
            var cy = node._groups[0][0].attributes.cy.value;

            d3.select("#vis_svg")
                .insert("circle", "circle")
                .attr("id", "pulseCircle")
                .attr("cx", cx)
                .attr("cy", cy)
                .attr("r", rScale(dot_radius + 8.75))
                .attr("fill", "#0d6efd")
                .attr("stroke", "#0d6efd")
                .each(pulse);

            node.attr("stroke", "#0d6efd").attr("fill", "white");

            const route = data.table_update.route.split(";");
            console.log(route);
            for(let i = 0; i<route.length-1; i++){
                connectNodesByArrow(data.nodes[route[i] ], data.nodes[route[i+1] ], d3.select("#vis_svg"), false, true);
            }
            console.log(data.table_update);   
            d3.select(`#nodeCircle${data.table_update.destination}`).style("stroke","#0d6efd");
        }

        function dataViz(data){
            d3.select(`#nodeCircle${data.actions.sending}`).attr("fill", "#bce6eb");
            const route = data.packet.route.split(";");
            console.log(route);
            for(let i = 0; i<route.length-1; i++){
                connectNodesByArrow(data.nodes[route[i] ], data.nodes[route[i+1] ], d3.select("#vis_svg"), false, true);
            }
            for(let i = 0; i < data.actions.receiving_discarding.length; i++){
                d3.select(`#nodeCircle${data.actions.receiving_discarding[i]}`).attr("fill", "#ff8585");
            }
            for(let i = 0; i < data.actions.receiving_processing.length; i++){
                d3.select(`#nodeCircle${data.actions.receiving_processing[i]}`).attr("fill", "#d2f5e3");
                connectNodesByArrow(data.nodes[data.actions.sending ], data.nodes[data.actions.receiving_processing[i] ], d3.select("#vis_svg"));
            }
        }

        function ack(data){
            d3.select(`#nodeCircle${data.actions.sending}`).attr("fill", "#bce6eb");
            for(let i = 0; i < data.actions.receiving_discarding.length; i++){
                d3.select(`#nodeCircle${data.actions.receiving_discarding[i]}`).attr("fill", "#ff8585");
            }
            for(let i = 0; i < data.actions.receiving_processing.length; i++){
                d3.select(`#nodeCircle${data.actions.receiving_processing[i]}`).attr("fill", "#d2f5e3");
                connectNodesByArrow(data.nodes[data.actions.sending ], data.nodes[data.actions.receiving_processing[i] ], d3.select("#vis_svg"), true, false,  "green");
            }
        }

        function rerr(data){
            //not implemented yet
        }

        function changeState(d){
            console.log(d);
            d3.select("#specificNodeInfo").remove();
            d3.select("#initNodeInfo").remove();
            d3.select("#nodeInfo")
                .append("div")
                .classed("card-body", true)
                .attr("id", "initNodeInfo")
                .style("position", "absolute")
                .style("visibility", "hidden")
                .style("visibility", "visible")
                .style("position", "relative")
                .html(`<h5 class="card-title">Node Info</h5>
                  <p class="card-text">Selektiere eine Node um weitere Informationen zu erhalten</p>`);
            d3.select(`#logElement${currentState}`).style("color", "black").style("font-weight", "normal");
            currentState = d;
            d3.select(`#logElement${currentState}`).style("color", "#0d6efd").style("font-weight", "700");
            switch (testdata[currentState].type){
                case "RREQ":
                    resetViz();
                    initViz(testdata[currentState].nodes);
                    rreq(testdata[currentState]);
                    break;
                case "RRES":
                    resetViz();
                    initViz(testdata[currentState].nodes);
                    rres(testdata[currentState]);
                    break;
                case "INIT":
                    resetViz();
                    initViz(testdata[currentState].nodes);
                    break;
                case "ACK":
                    resetViz();
                    initViz(testdata[currentState].nodes);
                    ack(testdata[currentState]);
                    break;
                case "RRER":
                    resetViz();
                    initViz(testdata[currentState].nodes);
                    rerr(testdata[currentState]);
                    break;
                case "DATA":
                    resetViz();
                    initViz(testdata[currentState].nodes);
                    dataViz(testdata[currentState]);
                    break;
                case "RTU":
                    resetViz();
                    initViz(testdata[currentState].nodes);
                    rtu(testdata[currentState]);
                    break;
                default:
                    break;
            }
        }


        var data = []

        initViz(data);

        //DOM Event Handlers
        const inputElement = document.getElementById("upload");
        inputElement.addEventListener("change", handleFiles, false);
        function handleFiles() {
            const fileList = this.files;
            console.log(this.files);

            const reader = new FileReader();

            reader.addEventListener('load', (event) => {
                //reset log data
                d3.select("#initDataLog").remove()
                currentState = 0;
                const parsed = JSON.parse(event.target.result);
                testdata = parsed;

                const init = parsed.filter(d => d.type == "INIT")[0];


                //set config
                d3.select("#title").style("visibility", "visible").style("position", "relative");
                document.getElementById("numOfNodes").innerHTML = init.nodes.length;
                document.getElementById("xsize").innerHTML = init.xsize + " |";
                document.getElementById("ysize").innerHTML = init.ysize + " |";

                resetViz();
                initViz(init.nodes);
                let html = `<h5 class="card-title">Daten Log</h5><div class="row"><div class="col">`;

                for(x in parsed){
                    html += `<span onclick="changeState(${x})" onmouseover="" style="cursor: pointer;" id="logElement${x}">${x}: ${parsed[x].type}<br/></span>`;
                    if(~~((parsed.length-1) / 2) == x){
                        html += "</div><div class='col'>";
                    }
                }
                html += "</div></div>";
                d3.select("#dataLog").append("div").attr("id", "initDataLog").classed("card-body", true).html(html);
                //coloring current state green
                d3.select(`#logElement${currentState}`).style("color", "#0d6efd").style("font-weight", "700");

                document.getElementById("dataRagenSlider").innerHTML = `<input type="range" class="form-range" min="0" max="${parsed.length-1}" value=${currentState} step="1" oninput="changeState(this.value)" id="customRange3">`;

            });

            reader.readAsText(this.files[0])
        }


         //ARROWS
        //takes two nodes and the svg element and a boolean withAnimation
        function connectNodesByArrow(nodeFrom, nodeTo, svg, withAnimation = true, withDottedLine = false, color = "black") {
            //change markerSize to change the marker size lol
            const markerSizeUnscaled = dot_radius * 0.8;
            const markerSize = rScale(markerSizeUnscaled);
            
            //only draw arrow, if there is enough space for it
            if(getDistanceBetweenNodes(nodeFrom, nodeTo) <= markerSizeUnscaled + dot_radius*2) return
            
            const refX = markerSize /12 * 11;
            const refY = markerSize / 2;

            const x = d3.scaleLinear()
            .domain([0, 100])         // This is the min and the max of the data: 0 to 100 if percentages
            .range([0, width]);       // This is the corresponding value I want in Pixel

             // X scale and Axis
             const y = d3.scaleLinear()
             .domain([0, 100])         // This is the min and the max of the data: 0 to 100 if percentages
             .range([height, 0]);       // This is the corresponding value I want in Pixel

            //define arrowHead
            svg.append("svg:defs").append("svg:marker")
                .attr("id", "arrowHead")
                .attr("refX", refX)
                .attr("refY", refY)
                .attr("markerWidth", markerSize)
                .attr("markerHeight", markerSize )
                .attr("orient", "auto")
                .append("path")
                //scale graphic according to markerSize - DO NOT EDIT
                .attr("d", `M${markerSize/6},${markerSize/6} L${markerSize/6*5},${markerSize/6*3} L${markerSize/6},${markerSize/6*5} L${markerSize/6*3},${markerSize/6*3} L${markerSize/6},${markerSize/6}`)
                .style("stroke", color);

            //calculate arrowCoordinates
            var normedDirVector = calculateNormedDirectionVector(nodeFrom, nodeTo)
            var arrowCoords = transformCoordsToCircleOutline(nodeFrom, nodeTo, normedDirVector)

            //create line with arrow
            var arrowLine = svg.append("line")
                .attr("x1", x(arrowCoords.x1))
                .attr("y1", y(arrowCoords.y1))
                .attr("x2", x(arrowCoords.x2))
                .attr("y2", y(arrowCoords.y2))
                .attr("stroke", color)
                .attr("stroke-width", 1.5)
                .attr("marker-end", "url(#arrowHead)")

            if(withDottedLine) {
                arrowLine
                .attr("stroke-dasharray","5,5")
                .attr("d","M5 40 l215 0")
            }

            //create arrow for animation
            var arrowAnimation = svg.append("line")
            .attr("marker-end", "url(#arrowHead)")

            var animationCoords = {
                x1:arrowCoords.x1,
                y1:arrowCoords.y1,
                x2start:arrowCoords.x1 + normedDirVector.x * markerSizeUnscaled,
                y2start:arrowCoords.y1 + normedDirVector.y * markerSizeUnscaled,
                x2end:arrowCoords.x2,
                y2end:arrowCoords.y2
            } 

            //don't add animation, if there is not enought space
            if(withAnimation) {
            repeatedArrowAnimation();
            //start and repeat the animation
            function repeatedArrowAnimation() {
                arrowAnimation.
                attr("x1", x(animationCoords.x1))
                .attr("y1", y(animationCoords.y1))
                .attr("x2", x(animationCoords.x2start))
                .attr("y2", y(animationCoords.y2start))
                .attr("stroke", color)
                .attr("stroke-width", 1.5)
                .transition()
                .ease(d3.easeLinear)
                .duration(2000)
                .attr("x2", x(animationCoords.x2end))
                .attr("y2", y(animationCoords.y2end))
                .on("end", repeatedArrowAnimation)
            }
        }

        }

        //takes two nodes and returns Directional Vector from x1 to x2 with {x, y} that has the length of 1 
        function calculateNormedDirectionVector(nodeFrom, nodeTo) {
            //AB = - A + B
            var dirVector = {
                x: - nodeFrom.x + nodeTo.x,
                y: - nodeFrom.y + nodeTo.y
            }

            var lengthOfVector = Math.sqrt(Math.pow(dirVector.x, 2) + Math.pow(dirVector.y, 2));

            //bring vector to length of 1
            normedDirVector = {
                x: dirVector.x / lengthOfVector,
                y: dirVector.y / lengthOfVector
            }
            return normedDirVector;
        }

        //takes two nodes and calculates the distance in scaled Units
        function getDistanceBetweenNodes(nodeFrom, nodeTo) {
            //AB = - A + B
            var dirVector = {
                x: - nodeFrom.x + nodeTo.x,
                y: - nodeFrom.y + nodeTo.y
            }

            return lengthOfVector = Math.sqrt(Math.pow(dirVector.x, 2) + Math.pow(dirVector.y, 2));
        }

        //takes two nodes and the dirVector with {x,y} and returns the new arrow start and end coords as object {x1,y1,x2,y2}
        function transformCoordsToCircleOutline(nodeFrom, nodeTo, normedDirVector) {
            //scale normed DirVector according to radius of nodes
            var dirVector = {
                x: normedDirVector.x * dot_radius,
                y: normedDirVector.y * dot_radius
            };
            return {
                x1: nodeFrom.x + dirVector.x,
                y1: nodeFrom.y + dirVector.y,
                x2: nodeTo.x - dirVector.x,
                y2: nodeTo.y - dirVector.y
            }
        }
    </script>
</body>

</html>