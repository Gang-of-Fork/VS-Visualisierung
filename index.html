<!doctype html>
<html lang="de">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">

    <title>Visualisierung Verteilte Systeme</title>
</head>

<body>
    <div id="title" style="visibility: hidden; position: absolute;">
        <h3>X-Größe: <span id="xsize"></span> Y-Größe: <span id="ysize"></span> Anzahl der Nodes: <span
                id="numOfNodes"></span></h3>
    </div>
    <div class="row">
        <div id="visualization" class="col"></div>
        <div class="col">
            <div class="row">
                <div class="col">
                    <div class="card" style="margin-bottom: 30px;">
                        <div class="card-body">
                            <div class="mb-3">
                                <label for="formFile" class="form-label">Daten auswählen</label>
                                <input class="form-control" type="file" id="upload">
                            </div>
                        </div>
                    </div>
                    <div id="dataInfo" class="card" style="width: 100%;">
                        <div id="initDataInfo" class="card-body">
                            <h5 class="card-title">Daten Info</h5>
                            <p class="card-text">Hier werden Informationen zum aktuell ausgewählten Daten Log Eintrag angezeigt</p>
                        </div>
                    </div>
                </div>
                <div class="col">
                    <div id="nodeInfo" class="card" style="width: 100%; max-height: 800px; overflow-y: auto">
                        <div id="initNodeInfo" class="card-body">
                            <h5 class="card-title">Node Info</h5>
                            <p class="card-text">Selektiere eine Node um weitere Informationen zu erhalten</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="row">
            <!--Slider for Log Navigation-->
            <div class="row">
                <div style="text-align: center; margin-top: 20px; padding: 10px;">
                    <div id="dataRagenSlider"></div>
                </div>
            </div>
            <div class="col">
                <div id="dataLog" class="card" style="width: 100%;">
                    <div id="initDataLog" class="card-body">
                        <h5 class="card-title">Daten Log</h5>
                        <p class="card-text">Lade eine Datei hoch, um hier den Log zu verfolgen</p>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <!-- Optional JavaScript; choose one of the two! -->

    <!-- Option 1: Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
        crossorigin="anonymous"></script>

    <!-- Include D3.js -->
    <script src="https://d3js.org/d3.v4.js"></script>

    <style>
        body {
            margin: 40px;
        }


        .shadow {
            -webkit-filter: drop-shadow(0px 0px 5px white);
            filter: drop-shadow(0px 0px 5px #000);
            /* Same syntax as box-shadow */
        }
    </style>

    <!-- Configuration constants -->
    <script>
        const dot_radius = 0.75;
        const default_coord = 100;
    </script>

    <!-- Custom D3.js code -->
    <script>
        var currentState = 0;
        var testdata; //will be assigned if data is read
        var x;
        var y;


        // set the dimensions and margins of the graph
        const margin = { top: 30, right: 30, bottom: 30, left: 30 };
        const width = 800 - margin.left - margin.right;
        const height = 800 - margin.top - margin.bottom;

        let rScale;


        function initViz(data) {

            const nodeInfo = d3.select("#nodeInfo")
                .append("div")
                .classed("card-body", true)
                .style("position", "absolute")
                .style("visibility", "hidden")
                .text("I'm a Node Info");


            //reset function for later selection
            const resetSelection = function () {
                //reset stroke width
                d3.selectAll("circle").attr("stroke-width", "1px");
                d3.select("#circleRange").remove();
                //remove card info
                d3.select("#initNodeInfo").remove();
                d3.select("#specificNodeInfo").remove();
                return d3.select("#nodeInfo")
                    .append("div")
                    .classed("card-body", true)
                    .attr("id", "initNodeInfo")
                    .style("visibility", "visible")
                    .style("position", "relative")
                    .html(`<h5 class="card-title">Node Info</h5>
                  <p class="card-text">Selektiere eine Node um weitere Informationen zu erhalten</p>`);
            }

            //append the svg object to the visualization div
            const svg = d3.select("#visualization")
                .append("svg")
                .on("click", resetSelection)
                .attr("id", "svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                // translate this svg element to leave some margin.
                .append("g")
                .attr("id", "vis_svg")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

            //adjust axis scale to testdata
            const xsize = data.xsize ? data.xsize : default_coord;
            const ysize = data.ysize ? data.ysize : default_coord;

            //R Scale and label size
            rScale = d3.scaleLinear()
                .domain([0, xsize])
                .range([0, height])

            const label_size = rScale(dot_radius) * 1.2;

            // X scale and Axis
            x = d3.scaleLinear()
                .domain([0, xsize])         // This is the min and the max of the data: 0 to 100 if percentages
                .range([0, width]);       // This is the corresponding value I want in Pixel

            svg
                .append('g')
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));

            // X scale and Axis
            y = d3.scaleLinear()
                .domain([0, ysize])         // This is the min and the max of the data: 0 to 100 if percentages
                .range([height, 0]);       // This is the corresponding value I want in Pixel

            svg
                .append('g')
                .call(d3.axisLeft(y))

            const tooltip = d3.select("#visualization")
                .append("div")
                .classed("card", true)
                .attr("id", "circleBasicTooltip")
                .style("position", "absolute")
                .style("visibility", "hidden")
                .style("z-index", "900")
                .text("I'm a circle!");

            //define Node-Events
            const mouseover = function (d) {
                d3.select(this).style("cursor", "pointer");
                return tooltip
                    .style("visibility", "visible")
                    .html("Node ID: " + d.id + "<br/> X: " + d.x + " Y: " + d.y);
            }

            const mousemove = function () {
                return tooltip.style("top", (event.pageY - 20) + "px")
                    .style("left", (event.pageX + 20) + "px")
            }

            const mouseleave = function () {
                d3.select(this).style("cursor", "default");
                return tooltip.style("visibility", "hidden");
            }

            const click = function (d) {
                event.stopPropagation();
                //remove card info
                d3.select("#initNodeInfo").remove();
                d3.select("#specificNodeInfo").remove();
                //change stroke-width of selected node
                d3.selectAll("circle").attr("stroke-width", "1px");
                var node = d3.select(`#nodeCircle${d.id}`).attr("stroke-width", "1.5px");
                //d3.select("#vis_svg").append("use").attr("xlink:href", `#nodeCircle${d.id}`);
                //d3.select("#vis_svg").append("use").attr("xlink:href", `#nodeText${d.id}`);
                d3.select("#circleRange").remove();
                var cx = node._groups[0][0].attributes.cx.value;
                var cy = node._groups[0][0].attributes.cy.value;
                //set range of nodes
                d3.select("#vis_svg").insert("circle", "circle")
                    .attr("id", "circleRange")
                    .attr("cx", cx)
                    .attr("cy", cy)
                    .attr("r", rScale(10))
                    .style("stroke-dasharray", ("10,5"))
                    .style("stroke", "green")
                    .style("fill-opacity", .2)
                    .style("fill", "green");
                let html = `<h5 class="card-title">Node Info</h5>
                        <h6 class="card-subtitle mb-2 text-muted">Node ID: ${d.id}</h6>
                        <p class="card-text">X: ${d.x}, Y: ${d.y} </br>`
                if (d.inRange.length > 0) {
                    html += `In Reichweite: ${d.inRange}`
                }
                if (d.routingTable.length > 0) {
                    html += `<h6>Routing Tabelle:</h6>
                            <table class="table">
                            <thead>
                                <tr>
                                <th scope="col">Destination</th>
                                <th scope="col">Route</th>
                                </tr>
                            </thead>
                            <tbody>`
                    for (let x of d.routingTable) {
                        html += `<tr>
                                    <td>${x.destination}</td>
                                    <td>${x.route.replaceAll(";", " - ")}</td>
                                </tr>`
                    }
                    html += `</tbody></table>`
                }
                html += `</p>`

                return d3.select("#nodeInfo")
                    .append("div")
                    .classed("card-body", true)
                    .attr("id", "specificNodeInfo")
                    .style("visibility", "visible")
                    .style("position", "relative")
                    .html(html);
            }

            const elemEnter = svg
                .selectAll("enterEle")
                .data(data.nodes)
                .enter()

            const circles = elemEnter
                .append("circle")
                .attr("id", function (d) { return "nodeCircle" + d.id })
                .attr("cx", function (d) { return x(d.x) })
                .attr("cy", function (d) { return y(d.y) })
                .attr("r", rScale(dot_radius))
                .attr("stroke", "black")
                .attr("fill", "white")
                .on("mouseover", mouseover)
                .on("mousemove", mousemove)
                .on("mouseleave", mouseleave)
                .on("click", click);

            const texts = elemEnter
                .append("text")
                .attr("id", function (d) { return "nodeText" + d.id })
                .attr("x", function (d) { return x(d.x) })
                .attr("y", function (d) { return y(d.y) + 0.4 * label_size })
                .attr('font-size', label_size)
                .attr("text-anchor", "middle")
                .text(function (d) { return "" + d.id })
                .on("mouseover", mouseover)
                .on("mousemove", mousemove)
                .on("mouseleave", mouseleave)
                .on("click", click);
        }

        function resetViz() {
            document.getElementsByTagName("div");
            document.getElementById("visualization").innerHTML = "";
        }


        function rreq(data) {
            d3.select(`#nodeCircle${data.actions.sending}`).attr("fill", "#bce6eb");
            d3.select("#vis_svg").append("use").attr("xlink:href", `#nodeCircle${data.actions.sending}`);
            d3.select("#vis_svg").append("use").attr("xlink:href", `#nodeText${data.actions.sending}`);
            for (let i = 0; i < data.actions.receiving_discarding.length; i++) {
                d3.select(`#nodeCircle${data.actions.receiving_discarding[i]}`).attr("fill", "#ff8585");
            }
            for (let i = 0; i < data.actions.receiving_processing.length; i++) {
                d3.select(`#nodeCircle${data.actions.receiving_processing[i]}`).attr("fill", "#d2f5e3");
                connectNodesByArrow(data.nodes[data.actions.sending], data.nodes[data.actions.receiving_processing[i]], d3.select("#vis_svg"));
            }
        }

        function rres(data) {
            d3.select(`#nodeCircle${data.actions.sending}`).attr("fill", "#bce6eb");
            d3.select("#vis_svg").append("use").attr("xlink:href", `#nodeCircle${data.actions.sending}`);
            d3.select("#vis_svg").append("use").attr("xlink:href", `#nodeText${data.actions.sending}`);
            for (let i = 0; i < data.actions.receiving_discarding.length; i++) {
                d3.select(`#nodeCircle${data.actions.receiving_discarding[i]}`).attr("fill", "#ff8585");
            }
            for (let i = 0; i < data.actions.receiving_processing.length; i++) {
                d3.select(`#nodeCircle${data.actions.receiving_processing[i]}`).attr("fill", "#d2f5e3");
                connectNodesByArrow(data.nodes[data.actions.sending], data.nodes[data.actions.receiving_processing[i]], d3.select("#vis_svg"));
            }
        }

        function rtu(data) {
            const pulse = function () {
                var circle = d3.select("#pulseCircle");
                (function repeat() {
                    circle = circle.transition()
                        //reset pulsing circle to node size
                        .duration(0)
                        .attr("stroke-width", 1.25)
                        .attr("r", rScale(dot_radius))
                        .style("opacity", "1")
                        //let circle grow and fade the color out
                        .transition()
                        .duration(2000)
                        //.ease(d3.easeLinear)
                        .attr('stroke-width', 1.25)
                        .attr("r", rScale(dot_radius + 8.75))
                        .style("opacity", "0")
                        .on("end", repeat);
                })();
            }
            var node = d3.select(`#nodeCircle${data.table_update.node}`);
            var cx = node._groups[0][0].attributes.cx.value;
            var cy = node._groups[0][0].attributes.cy.value;

            d3.select("#vis_svg").append("use").attr("xlink:href", `#nodeCircle${data.table_update.node}`);
            d3.select("#vis_svg").append("use").attr("xlink:href", `#nodeText${data.table_update.node}`);

            d3.select("#vis_svg")
                .insert("circle", "circle")
                .attr("id", "pulseCircle")
                .attr("cx", cx)
                .attr("cy", cy)
                .attr("r", rScale(10))
                .attr("fill", "#0d6efd")
                .attr("stroke", "#0d6efd")
                .each(pulse);

            node.attr("stroke", "#0d6efd").attr("fill", "white");

            const route = data.table_update.route.split(";");
            var color = data.table_update.type == "remove" ? "red" : (data.table_update.type == "update" ? "green" : "black");
            for(let i = 0; i<route.length-1; i++){
                connectNodesByArrow(data.nodes[route[i] ], data.nodes[route[i+1] ], d3.select("#vis_svg"), false, true, color);
            }
            d3.select(`#nodeCircle${data.table_update.destination}`).style("stroke", "#0d6efd");
        }

        function dataViz(data) {
            d3.select(`#nodeCircle${data.actions.sending}`).attr("fill", "#bce6eb");
            d3.select("#vis_svg").append("use").attr("xlink:href", `#nodeCircle${data.actions.sending}`);
            d3.select("#vis_svg").append("use").attr("xlink:href", `#nodeText${data.actions.sending}`);
            const route = data.packet.route.split(";");
            for (let i = 0; i < route.length - 1; i++) {
                connectNodesByArrow(data.nodes[route[i]], data.nodes[route[i + 1]], d3.select("#vis_svg"), false, true);
            }
            for (let i = 0; i < data.actions.receiving_discarding.length; i++) {
                d3.select(`#nodeCircle${data.actions.receiving_discarding[i]}`).attr("fill", "#ff8585");
            }
            for (let i = 0; i < data.actions.receiving_processing.length; i++) {
                d3.select(`#nodeCircle${data.actions.receiving_processing[i]}`).attr("fill", "#d2f5e3");
                connectNodesByArrow(data.nodes[data.actions.sending], data.nodes[data.actions.receiving_processing[i]], d3.select("#vis_svg"));
            }
        }

        function ack(data) {
            d3.select(`#nodeCircle${data.actions.sending}`).attr("fill", "#bce6eb");
            d3.select("#vis_svg").append("use").attr("xlink:href", `#nodeCircle${data.actions.sending}`);
            d3.select("#vis_svg").append("use").attr("xlink:href", `#nodeText${data.actions.sending}`);
            for (let i = 0; i < data.actions.receiving_discarding.length; i++) {
                d3.select(`#nodeCircle${data.actions.receiving_discarding[i]}`).attr("fill", "#ff8585");
            }
            for (let i = 0; i < data.actions.receiving_processing.length; i++) {
                d3.select(`#nodeCircle${data.actions.receiving_processing[i]}`).attr("fill", "#d2f5e3");
                connectNodesByArrow(data.nodes[data.actions.sending], data.nodes[data.actions.receiving_processing[i]], d3.select("#vis_svg"), true, false, "green");
            }
        }

        function rerr(data) {
            d3.select(`#nodeCircle${data.actions.sending}`).attr("fill", "#bce6eb");
            d3.select("#vis_svg").append("use").attr("xlink:href", `#nodeCircle${data.actions.sending}`);
            d3.select("#vis_svg").append("use").attr("xlink:href", `#nodeText${data.actions.sending}`);
            for (let i = 0; i < data.actions.receiving_discarding.length; i++) {
                d3.select(`#nodeCircle${data.actions.receiving_discarding[i]}`).attr("fill", "#ff8585");
            }
            for (let i = 0; i < data.actions.receiving_processing.length; i++) {
                d3.select(`#nodeCircle${data.actions.receiving_processing[i]}`).attr("fill", "#d2f5e3");
                connectNodesByArrow(data.nodes[data.actions.sending], data.nodes[data.actions.receiving_processing[i]], d3.select("#vis_svg"), true, false, "red");
            }
        }

        function changeState(d) {
            d3.select("#initDataInfo").remove();
            d3.select("#specificDataInfo").remove();
            let html = `<h5 class="card-title">Daten Info</h5>
                    <h6 class="card-subtitle mb-2 text-muted">Type: ${testdata[d].type}</h6>`
            if (testdata[d].type != "INIT" && testdata[d].type != "RTU" ){
                html += `<p class="card-text">ID: ${testdata[d].packet.id} </br> Ziel: ${testdata[d].packet.dest} </br>Ursprung: ${testdata[d].packet.source} </br>Route: ${testdata[d].packet.route.replaceAll(";", " - ")}</p>`
            } else if (testdata[d].type == "RTU"){
                let description = testdata[d].table_update.type == "add" ? "Route hinzugefügt" : (testdata[d].table_update.type == "update" ? "Route erneuert": "Route entfernt") 
                html += `<h6>${description}</h6><p class="card-text"> Node: ${testdata[d].table_update.node} </br> Ziel: ${testdata[d].table_update.destination} </br> Route: ${testdata[d].table_update.route.replaceAll(";", " - ")}</p>`
            } else {
                html += `<p class="card-text">Initiale Node Anordnung</p>`
            }

            d3.select("#dataInfo")
                .append("div")
                .classed("card-body", true)
                .attr("id", "specificDataInfo")
                .style("visibility", "visible")
                .style("position", "relative")
                .html(html);

            d3.select("#specificNodeInfo").remove();
            d3.select("#initNodeInfo").remove();
            d3.select("#nodeInfo")
                .append("div")
                .classed("card-body", true)
                .attr("id", "initNodeInfo")
                .style("position", "absolute")
                .style("visibility", "hidden")
                .style("visibility", "visible")
                .style("position", "relative")
                .html(`<h5 class="card-title">Node Info</h5>
                  <p class="card-text">Selektiere eine Node um weitere Informationen zu erhalten</p>`);

            d3.select(`#logElement${currentState}`).style("color", "black").style("font-weight", "normal");
            currentState = d;
            d3.select(`#logElement${currentState}`).style("color", "#0d6efd").style("font-weight", "700");
            console.log(currentState);
            console.log(d3.select(`#logElement${currentState}`).style("color", "#0d6efd").style("font-weight", "700"));
            switch (testdata[currentState].type) {
                case "RREQ":
                    resetViz();
                    initViz(testdata[currentState]);
                    rreq(testdata[currentState]);
                    break;
                case "RRES":
                    resetViz();
                    initViz(testdata[currentState]);
                    rres(testdata[currentState]);
                    break;
                case "INIT":
                    resetViz();
                    initViz(testdata[currentState]);
                    break;
                case "ACK":
                    resetViz();
                    initViz(testdata[currentState]);
                    ack(testdata[currentState]);
                    break;
                case "RERR":
                    resetViz();
                    initViz(testdata[currentState]);
                    rerr(testdata[currentState]);
                    break;
                case "DATA":
                    resetViz();
                    initViz(testdata[currentState]);
                    dataViz(testdata[currentState]);
                    break;
                case "RTU":
                    resetViz();
                    initViz(testdata[currentState]);
                    rtu(testdata[currentState]);
                    break;
                default:
                    break;
            }
        }


        var data = { nodes: [] }

        initViz(data);

        //DOM Event Handlers
        const inputElement = document.getElementById("upload");
        inputElement.addEventListener("change", handleFiles, false);
        function handleFiles() {
            const fileList = this.files;

            const reader = new FileReader();

            reader.addEventListener('load', (event) => {
                //reset log data
                d3.select("#initDataLog").remove()
                currentState = 0;
                const parsed = JSON.parse(event.target.result);
                testdata = parsed;

                const init = parsed.filter(d => d.type == "INIT")[0];


                //set config
                d3.select("#title").style("visibility", "visible").style("position", "relative");
                document.getElementById("numOfNodes").innerHTML = init.nodes.length;
                document.getElementById("xsize").innerHTML = init.xsize + " |";
                document.getElementById("ysize").innerHTML = init.ysize + " |";

                resetViz();
                d3.select("#specificDataInfo").remove();
                d3.select("#specificNodeInfo").remove();
                d3.select("#initDataInfo").remove();
                d3.select("#initNodeInfo").remove();
                d3.select("#nodeInfo")
                    .append("div")
                    .classed("card-body", true)
                    .attr("id", "initNodeInfo")
                    .style("visibility", "visible")
                    .style("position", "relative")
                    .html(`<h5 class="card-title">Node Info</h5>
                        <p class="card-text">Selektiere eine Node um weitere Informationen zu erhalten</p>`);
                d3.select("#dataInfo")
                    .append("div")
                    .classed("card-body", true)
                    .attr("id", "initDataInfo")
                    .style("visibility", "visible")
                    .style("position", "relative")
                    .html(`<h5 class="card-title">Daten Info</h5>
                        <p class="card-text">Hier werden Informationen zum aktuell ausgewählten Daten Log Eintrag angezeigt</p>`);
                initViz(init);
                let html = `<h5 class="card-title">Daten Log</h5><div class="row"><div class="col">`;
                var multpl = 1;
                for (x in parsed) {
                    html += `<span onclick="changeState(${x})" onmouseover="" style="cursor: pointer;" id="logElement${x}">${x}: ${parsed[x].type}<br/></span>`;
                    if (~~((parsed.length) / 8 * multpl) == x) {
                        multpl++;
                        html += "</div><div class='col'>";
                    }
                }
                html += "</div></div>";
                d3.select("#dataLog").append("div").attr("id", "initDataLog").classed("card-body", true).html(html);
                //coloring current state green
                d3.select(`#logElement${currentState}`).style("color", "#0d6efd").style("font-weight", "700");

                document.getElementById("dataRagenSlider").innerHTML = `<input type="range" class="form-range" min="0" max="${parsed.length - 1}" value=${currentState} step="1" oninput="changeState(this.value)" id="customRange3">`;

            });

            reader.readAsText(this.files[0])
        }


        //ARROWS
        //takes two nodes and the svg element and a boolean withAnimation
        function connectNodesByArrow(nodeFrom, nodeTo, svg, withAnimation = true, withDottedLine = false, color = "black") {
            //change markerSize to change the marker size lol
            const markerSizeUnscaled = dot_radius * 0.8;
            const markerSize = rScale(markerSizeUnscaled);

            //only draw arrow, if there is enough space for it
            if (getDistanceBetweenNodes(nodeFrom, nodeTo) <= markerSizeUnscaled + dot_radius * 2) return

            const refX = markerSize / 12 * 11;
            const refY = markerSize / 2;

            //define arrowHead
            svg.append("svg:defs").append("svg:marker")
                .attr("id", "arrowHead")
                .attr("refX", refX)
                .attr("refY", refY)
                .attr("markerWidth", markerSize)
                .attr("markerHeight", markerSize)
                .attr("orient", "auto")
                .append("path")
                //scale graphic according to markerSize - DO NOT EDIT
                .attr("d", `M${markerSize / 6},${markerSize / 6} L${markerSize / 6 * 5},${markerSize / 6 * 3} L${markerSize / 6},${markerSize / 6 * 5} L${markerSize / 6 * 3},${markerSize / 6 * 3} L${markerSize / 6},${markerSize / 6}`)
                .style("stroke", color);

            //calculate arrowCoordinates
            var normedDirVector = calculateNormedDirectionVector(nodeFrom, nodeTo)
            var arrowCoords = transformCoordsToCircleOutline(nodeFrom, nodeTo, normedDirVector)

            //create line with arrow
            var arrowLine = svg.append("line")
                .attr("x1", x(arrowCoords.x1))
                .attr("y1", y(arrowCoords.y1))
                .attr("x2", x(arrowCoords.x2))
                .attr("y2", y(arrowCoords.y2))
                .attr("stroke", color)
                .attr("stroke-width", 1.5)
                .attr("marker-end", "url(#arrowHead)")

            if (withDottedLine) {
                arrowLine
                    .attr("stroke-dasharray", "5,5")
                    .attr("d", "M5 40 l215 0")
            }

            //create arrow for animation
            var arrowAnimation = svg.append("line")
                .attr("marker-end", "url(#arrowHead)")

            var animationCoords = {
                x1: arrowCoords.x1,
                y1: arrowCoords.y1,
                x2start: arrowCoords.x1 + normedDirVector.x * markerSizeUnscaled,
                y2start: arrowCoords.y1 + normedDirVector.y * markerSizeUnscaled,
                x2end: arrowCoords.x2,
                y2end: arrowCoords.y2
            }

            //don't add animation, if there is not enought space
            if (withAnimation) {
                repeatedArrowAnimation();
                //start and repeat the animation
                function repeatedArrowAnimation() {
                    arrowAnimation.
                        attr("x1", x(animationCoords.x1))
                        .attr("y1", y(animationCoords.y1))
                        .attr("x2", x(animationCoords.x2start))
                        .attr("y2", y(animationCoords.y2start))
                        .attr("stroke", color)
                        .attr("stroke-width", 1.5)
                        .transition()
                        .ease(d3.easeLinear)
                        .duration(2000)
                        .attr("x2", x(animationCoords.x2end))
                        .attr("y2", y(animationCoords.y2end))
                        .on("end", repeatedArrowAnimation)
                }
            }

        }

        //takes two nodes and returns Directional Vector from x1 to x2 with {x, y} that has the length of 1 
        function calculateNormedDirectionVector(nodeFrom, nodeTo) {
            //AB = - A + B
            var dirVector = {
                x: - nodeFrom.x + nodeTo.x,
                y: - nodeFrom.y + nodeTo.y
            }

            var lengthOfVector = Math.sqrt(Math.pow(dirVector.x, 2) + Math.pow(dirVector.y, 2));

            //bring vector to length of 1
            normedDirVector = {
                x: dirVector.x / lengthOfVector,
                y: dirVector.y / lengthOfVector
            }
            return normedDirVector;
        }

        //takes two nodes and calculates the distance in scaled Units
        function getDistanceBetweenNodes(nodeFrom, nodeTo) {
            //AB = - A + B
            var dirVector = {
                x: - nodeFrom.x + nodeTo.x,
                y: - nodeFrom.y + nodeTo.y
            }

            return lengthOfVector = Math.sqrt(Math.pow(dirVector.x, 2) + Math.pow(dirVector.y, 2));
        }

        //takes two nodes and the dirVector with {x,y} and returns the new arrow start and end coords as object {x1,y1,x2,y2}
        function transformCoordsToCircleOutline(nodeFrom, nodeTo, normedDirVector) {
            //scale normed DirVector according to radius of nodes
            var dirVector = {
                x: normedDirVector.x * dot_radius,
                y: normedDirVector.y * dot_radius
            };
            return {
                x1: nodeFrom.x + dirVector.x,
                y1: nodeFrom.y + dirVector.y,
                x2: nodeTo.x - dirVector.x,
                y2: nodeTo.y - dirVector.y
            }
        }
    </script>
</body>

</html>